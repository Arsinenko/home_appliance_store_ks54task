// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: customers.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO Customers (account_id, balance, created_at, is_alive)
VALUES ($1, $2, $3, $4)
RETURNING id, account_id, balance, created_at, is_alive
`

type CreateCustomerParams struct {
	AccountID int32
	Balance   pgtype.Numeric
	CreatedAt pgtype.Timestamp
	IsAlive   bool
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.AccountID,
		arg.Balance,
		arg.CreatedAt,
		arg.IsAlive,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Balance,
		&i.CreatedAt,
		&i.IsAlive,
	)
	return i, err
}

const deleteCustomer = `-- name: DeleteCustomer :exec
UPDATE Customers
SET is_alive = false
WHERE id = $1
`

func (q *Queries) DeleteCustomer(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCustomer, id)
	return err
}

const getCustomer = `-- name: GetCustomer :one
SELECT
    c.id, c.account_id, c.balance, c.created_at, c.is_alive,
    a.login as account_login,
    a.created_at as account_created_at,
    a.is_alive as account_is_alive

FROM Customers c
         JOIN Accounts a ON c.account_id = a.id
WHERE c.id = $1
LIMIT 1
`

type GetCustomerRow struct {
	ID               int32
	AccountID        int32
	Balance          pgtype.Numeric
	CreatedAt        pgtype.Timestamp
	IsAlive          bool
	AccountLogin     string
	AccountCreatedAt pgtype.Timestamp
	AccountIsAlive   bool
}

// Получаем покупателя вместе с его логином
func (q *Queries) GetCustomer(ctx context.Context, id int32) (GetCustomerRow, error) {
	row := q.db.QueryRow(ctx, getCustomer, id)
	var i GetCustomerRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Balance,
		&i.CreatedAt,
		&i.IsAlive,
		&i.AccountLogin,
		&i.AccountCreatedAt,
		&i.AccountIsAlive,
	)
	return i, err
}

const listCustomers = `-- name: ListCustomers :many
SELECT c.id, c.account_id, c.balance, c.created_at, c.is_alive,
       a.login as account_login,
       a.created_at as account_created_at,
       a.is_alive as account_is_alive
FROM Customers c
         JOIN Accounts a ON c.account_id = a.id
WHERE c.is_alive = true
ORDER BY c.id
`

type ListCustomersRow struct {
	ID               int32
	AccountID        int32
	Balance          pgtype.Numeric
	CreatedAt        pgtype.Timestamp
	IsAlive          bool
	AccountLogin     string
	AccountCreatedAt pgtype.Timestamp
	AccountIsAlive   bool
}

// Получаем список покупателей вместе с их логинами
func (q *Queries) ListCustomers(ctx context.Context) ([]ListCustomersRow, error) {
	rows, err := q.db.Query(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomersRow
	for rows.Next() {
		var i ListCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.Balance,
			&i.CreatedAt,
			&i.IsAlive,
			&i.AccountLogin,
			&i.AccountCreatedAt,
			&i.AccountIsAlive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE Customers
SET balance  = $2,
    is_alive = $3
WHERE id = $1
RETURNING id, account_id, balance, created_at, is_alive
`

type UpdateCustomerParams struct {
	ID      int32
	Balance pgtype.Numeric
	IsAlive bool
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, updateCustomer, arg.ID, arg.Balance, arg.IsAlive)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.Balance,
		&i.CreatedAt,
		&i.IsAlive,
	)
	return i, err
}
